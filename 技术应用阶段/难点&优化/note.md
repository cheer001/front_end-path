- [难点公关](#难点公关)
  - [defer 优化方案](#defer-优化方案)
    - [requestAnimationFrame](#requestanimationframe)
    - [分屏渲染](#分屏渲染)
    - [SSR](#ssr)

# 难点公关

> 回答问题遵循以下基本原则：

1. 遇到的问题或困难(S:Situation)
2. 列举问题难点或者思考过程(T:Task)
3. 根据确定的解决方案实施的行动(A:Action)
4. 解决问题的结果，对项目，对团队，对公司的帮助，对个人的提升(R:Result)

## defer 优化方案

- S
  因为我们的这个项目，用户首页打开的速度特别慢，无论我们自己测试也好，还是根据监控埋点反馈的数据也好，基本上可以排除其他网络因素，主要原因还是因为首屏渲染的 DOM 内容特别多。这个当然我们也清楚，所以**一开始就给用户做了骨架屏和延迟分屏渲染的相关优化**。

- T
  但是这两种方式并不能解决关键问题，骨架屏本身就是治标不治本的做法，而分屏渲染只是解决了不再当前视口 DOM 内容优化渲染的问题。而我们项目的麻烦点就在于，首屏内容本身的 DOM 阶段渲染就十分的多（可能**面试官会处于好奇**，什么项目首屏这么麻烦，一般涉及数据密集型 仪表盘显示的，DOM 会十分的密集），分屏分页只能解决不在当前视口内容渲染的问题。

- A
  当然也考虑过 SSR，但是 SSR 虽然是解决渲染问题的大招，但是本身该有的大量的 DOM 节点内容在客户端还是要进行渲染，而且最重要的是**项目的成本预算并不打算把压力放在服务器上来，这个想法也没有可行性**（**埋钩子：引起面试官兴趣**）

- R
  最后想到了**requestAnimationFrame** 进行分帧渲染的方式，和我们当时的需求是最契合的。根本原理就是借助 **RAF** 下一次重绘之前执行回调函数，将长任务分帧分解成一个个的短任务，当然还需要封装相关的脚本工具，探测页面的节点，根据节点渲染的优先级进行处理（**埋钩子：引起面试官兴趣**）

- 总结
  这样的处理，对原有的代码侵入性最少，而且以比较简单直接的方式，解决了首屏渲染时间过长的问题，经过这样优化之后，首屏的 FCP，LCP 时间大幅度降低，用户留存率（RR）也有明显的改善。
  (最后追问面试官，哪些地方需要详说明以下)

### requestAnimationFrame

- 使用场景

  1. 创建高性能动画
     requestAnimationFrame 是替代 setInterval 和 setTimeout 的最佳选择，因为它：

     自动优化帧率（基于显示器刷新率）。
     减少不必要的绘制，提升性能。
     动画在页面非激活时自动暂停，节省资源。
     示例场景：

     平滑滚动效果（如滚动到特定位置）。
     游戏动画帧渲染。
     元素平移动画（如滑动、缩放）。

  2. 分帧渲染
     处理大量 DOM 操作或数据时，可以将任务拆分为多帧完成，避免阻塞主线程导致页面卡顿。

     示例场景：

     渲染大列表（如虚拟滚动）。
     分帧加载图片。
     大型 SVG 或 Canvas 渲染。

  3. 减少性能瓶颈
     requestAnimationFrame 的回调是在浏览器的绘制周期中执行的，适用于优化与绘制相关的任务。

     示例场景：

     检测并动态调整布局变化。
     自适应动画或页面布局。

### 分屏渲染

使用浏览器提供的 IntersectionObserver,在 DOM 原始进入视口时进行渲染

### SSR

使用这个方案其实还是有一些缺点的，会产生纠纷 会因为不知道是否是前端代码性能问题 还是服务端响应到浏览器渲染问题
